In software engineering, behavior-driven development (BDD) is a software development process that emerged from test-driven development (TDD).

Behavior-driven development combines the general techniques and principles of TDD with ideas from domain-driven design and object-oriented analysis and design to provide software development and management teams with shared tools and a shared process to collaborate on software development.

Behavior-driven development was developed by Dan North as a response to the issues encountered teaching test-driven development:

    Where to start in the process
    What to test and what not to test
    How much to test in one go
    What to call the tests
    How to understand why a test fails

Principles of BDD
Behavior-driven development specifies that tests of any unit of software should be specified in terms of the desired behavior of the unit.Borrowing from agile software development the "desired behavior" in this case consists of the requirements set by the business — that is, the desired behavior that has business value for whatever entity commissioned the software unit under construction.Within BDD practice, this is referred to as BDD being an "outside-in" activity.

There are several different examples of BDD software tools in use in projects today, for different platforms and programming languages.

Possibly the most well-known is JBehave, which was developed by Dan North. The following is an example taken from that project:
Consider an implementation of the Game of Life. A domain expert (or business analyst) might want to specify what should happen when someone is setting up a starting configuration of the game grid. To do this, he might want to give an example of a number of steps taken by a person who is toggling cells. Skipping over the narrative part, he might do this by writing up the following scenario into a plain text document (which is the type of input document that JBehave reads):

Given a 5 by 5 game
When I toggle the cell at (3, 2)
Then the grid should look like
.....
.....
.....
..X..
.....
When I toggle the cell at (3, 1)
Then the grid should look like
.....
.....
.....
..X..
..X..
When I toggle the cell at (3, 2)
Then the grid should look like
.....
.....
.....
.....
..X..
The bold print is not actually part of the input; it is included here to show which words are recognized as formal language. JBehave recognizes the terms Given (as a precondition which defines the start of a scenario), When (as an event trigger) and Then (as a postcondition which must be verified as the outcome of the action that follows the trigger). Based on this, JBehave is capable of reading the text file containing the scenario and parsing it into clauses (a set-up clause and then three event triggers with verifiable conditions). JBehave then takes these clauses and passes them on to code that is capable of setting a test, responding to the event triggers and verifying the outcome. This code must be written by the developers in the project team (in Java, because that is the platform JBehave is based on). In this case, the code might look like this:

private Game game;
private StringRenderer renderer;

@Given("a $width by $height game")
public void theGameIsRunning(int width, int height) {
    game = new Game(width, height);
    renderer = new StringRenderer();
    game.setObserver(renderer);
}
    
@When("I toggle the cell at ($column, $row)")
public void iToggleTheCellAt(int column, int row) {
    game.toggleCellAt(column, row);
}

@Then("the grid should look like $grid")
public void theGridShouldLookLike(String grid) {
    assertThat(renderer.asString(), equalTo(grid));

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Jasmine is a behavior-driven development framework for testing JavaScript code. It does not depend on any other JavaScript frameworks. It does not require a DOM. And it has a clean, obvious syntax so that you can easily write tests.

Suites: describe Your Tests
A test suite begins with a call to the global Jasmine function describe with two parameters: a string and a function. The string is a name or title for a spec suite – usually what is being tested. The function is a block of code that implements the suite.
Jasmine is slightly newer to the pack, having been released 2 years after qUnit in 2010.  It’s on the edge of having had enough time to mature, while still having learned the lessons of other JavaScript test frameworks.  It’s built to be easy to set up and use in almost any scenario.  It requires a runner, such as Karma or Chutzpah, in most scenarios, but some distros (like the jasmine-node npm) have one baked in.

How’s it look?  It’s pretty nice for most scenarios you could want, asynchronous code being the main problem area.
Pros:

    Simple setup for node through jasmine-node
    Headless running out of the box
    Nice fluent syntax for assertions built-in, and does play pretty well with other assertion libraries
    Supported by many CI servers (TeamCity, Codeship, etc.) and some that don’t support natively have plugins (jenkins has a maven plugin)
    Descriptive syntax for BDD paradigm

Cons:

    Asynchronous testing can be a bit of a headache
    Expects a specific suffix to all test files (*spec.js by default)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
qUnit is definitely the oldest of the three on my list, having its first official release in 2008.  Because of this, it has picked up a good userbase over the years.  It’s seen popular use in jQuery, and has amazing support from a lot of places.

How does it stack up?  It’s really not pretty…
Pros:

    Lots of support across the board, from Q&A to CI server support

Cons:

    Lacks fluent syntax
    Configuration is a headache, and must constantly be maintained
    Makes including 3rd party libraries (like assertion libraries) relatively difficult
    Asynchronous testing can be a bit of a headache
    No baked-in headless run support
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Having been built specifically for testing nodeJs modules, Mocha is the baby of the bunch with its first major build released in 2012.  Its API is rather similar to that of Jasmine’s, with a bit of syntactic sugar added to make it more conductive to a wider range of scenarios, such as BDD. It has its own test runner baked in, so that’s a concern you should never have to worry about.  It also, unlike Jasmine, has really nice support for testing asynchronous methods, using the done() function: if your test uses it, the test doesn’t pass until done() is called, if it doesn’t use it, the test will pass when it reaches the end of the test method.

My impression?  Looks pretty darn good to me!
Pros:

    Simple setup
    Headless running out of the box
    Allows use of any assertion library that will throw exceptions on failure, such as Chai
    Supported by some CI servers and plugins for others (jenkins has a maven plugin)
    Has aliases for functions to be more BDD-oriented or TDD-oriented
    Highly extensible
    Asynchronous testing is a breeze

Cons:

    Newer to the field, so support might be lacking in certain areas


